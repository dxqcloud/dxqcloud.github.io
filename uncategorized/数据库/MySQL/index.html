<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cloud.png">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=EB Garamond:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"hide","padding":10,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/search.xml"};
  </script>

  <meta name="description" content="一、索引 B+ Tree 原理 MySQL 索引 索引优化 索引的优点 索引的使用条件   二、查询性能优化 使用 Explain 进行分析 优化数据访问 重构查询方式   三、存储引擎 InnoDB MyISAM 比较   四、数据类型 整型 浮点数 字符串 时间和日期   五、切分 水平切分 垂直切分 Sharding 策略 Sharding 存在的问题   六、复制 主从复制 读写分离">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库&#x2F;MySQL">
<meta property="og:url" content="http://yoursite.com/uncategorized/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/index.html">
<meta property="og:site_name" content="欢迎来到我的博客！">
<meta property="og:description" content="一、索引 B+ Tree 原理 MySQL 索引 索引优化 索引的优点 索引的使用条件   二、查询性能优化 使用 Explain 进行分析 优化数据访问 重构查询方式   三、存储引擎 InnoDB MyISAM 比较   四、数据类型 整型 浮点数 字符串 时间和日期   五、切分 水平切分 垂直切分 Sharding 策略 Sharding 存在的问题   六、复制 主从复制 读写分离">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/pics/33576849-9275-47bb-ada7-8ded5f5e7c73.png">
<meta property="og:image" content="http://yoursite.com/pics/45016e98-6879-4709-8569-262b2d6d60b9.png">
<meta property="og:image" content="http://yoursite.com/pics/7c349b91-050b-4d72-a7f8-ec86320307ea.png">
<meta property="og:image" content="http://yoursite.com/pics/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg">
<meta property="og:image" content="http://yoursite.com/pics/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg">
<meta property="og:image" content="http://yoursite.com/pics/master-slave.png">
<meta property="og:image" content="http://yoursite.com/pics/master-slave-proxy.png">
<meta property="og:image" content="https://cyc-1256109796.cos.ap-guangzhou.myqcloud.com/%E5%85%AC%E4%BC%97%E5%8F%B7.jpg">
<meta property="article:published_time" content="2020-03-09T06:20:06.728Z">
<meta property="article:modified_time" content="2019-10-28T12:21:49.409Z">
<meta property="article:author" content="DXQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/pics/33576849-9275-47bb-ada7-8ded5f5e7c73.png">

<link rel="canonical" href="http://yoursite.com/uncategorized/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

<!-- jquery -->

<script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <title>数据库/MySQL | 欢迎来到我的博客！</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">欢迎来到我的博客！</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/uncategorized/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="DXQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到我的博客！">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据库/MySQL
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-09 14:20:06" itemprop="dateCreated datePublished" datetime="2020-03-09T14:20:06+08:00">2020-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-28 20:21:49" itemprop="dateModified" datetime="2019-10-28T20:21:49+08:00">2019-10-28</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <!-- GFM-TOC -->
<ul>
<li><a href="#一索引">一、索引</a><ul>
<li><a href="#b-tree-原理">B+ Tree 原理</a></li>
<li><a href="#mysql-索引">MySQL 索引</a></li>
<li><a href="#索引优化">索引优化</a></li>
<li><a href="#索引的优点">索引的优点</a></li>
<li><a href="#索引的使用条件">索引的使用条件</a></li>
</ul>
</li>
<li><a href="#二查询性能优化">二、查询性能优化</a><ul>
<li><a href="#使用-explain-进行分析">使用 Explain 进行分析</a></li>
<li><a href="#优化数据访问">优化数据访问</a></li>
<li><a href="#重构查询方式">重构查询方式</a></li>
</ul>
</li>
<li><a href="#三存储引擎">三、存储引擎</a><ul>
<li><a href="#innodb">InnoDB</a></li>
<li><a href="#myisam">MyISAM</a></li>
<li><a href="#比较">比较</a></li>
</ul>
</li>
<li><a href="#四数据类型">四、数据类型</a><ul>
<li><a href="#整型">整型</a></li>
<li><a href="#浮点数">浮点数</a></li>
<li><a href="#字符串">字符串</a></li>
<li><a href="#时间和日期">时间和日期</a></li>
</ul>
</li>
<li><a href="#五切分">五、切分</a><ul>
<li><a href="#水平切分">水平切分</a></li>
<li><a href="#垂直切分">垂直切分</a></li>
<li><a href="#sharding-策略">Sharding 策略</a></li>
<li><a href="#sharding-存在的问题">Sharding 存在的问题</a></li>
</ul>
</li>
<li><a href="#六复制">六、复制</a><ul>
<li><a href="#主从复制">主从复制</a></li>
<li><a href="#读写分离">读写分离</a></li>
</ul>
</li>
<li><a href="#参考资料">参考资料</a><!-- GFM-TOC -->


</li>
</ul>
<h1><span id="yi-suo-yin">一、索引</span><a href="#yi-suo-yin" class="header-anchor">#</a></h1><h2><span id="b-tree-yuan-li">B+ Tree 原理</span><a href="#b-tree-yuan-li" class="header-anchor">#</a></h2><p>数据库索引是存储在磁盘上的，当数据量大时，不能一次性把所有索引加载到内存中，只能逐一加载磁盘项（对应索引树的节点）。因此为了加快索引速度，需要减少磁盘IO次数，也就是降低数的高度。而B树的特征就是矮胖，适合用于构建索引。</p>
<h3><span id="1-b-shu">1. B树</span><a href="#1-b-shu" class="header-anchor">#</a></h3><p>B 树的特征：</p>
<ul>
<li>关键字分布在整棵树中</li>
<li>任何一个关键字只出现在一个节点中</li>
<li>搜索有可能在叶子节点结束</li>
<li>所有叶子节点的高度相同<br>B树的详细介绍，请见数据结构笔记。</li>
</ul>
<h3><span id="2-b-shu">2. B+树</span><a href="#2-b-shu" class="header-anchor">#</a></h3><p>B+树 是基于B树的改进版。与B树最大的区别是，B树中所有节点都会存储数据地址（即每个节点既有关键字也有关键字对应的数据信息），而在B+树中，所有数据地址都只存在于叶子节点中。所有叶节点相连。</p>
<p>在B+树中会保存两个头指针，一个指向根节点，用于索引。另一个指向关键字最小的叶子节点，用于遍历。<br>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key<sub>i</sub> 和 key<sub>i+1</sub>，且不为 null，则该指针指向节点的所有 key 大于等于 key<sub>i</sub> 且小于等于 key<sub>i+1</sub>。</p>
<div align="center"> <img src="/pics/33576849-9275-47bb-ada7-8ded5f5e7c73.png" width="350px"> </div><br>
### 3. B+树相比B树的优势
（1）B+树的空间利用率更高，减少IO次数：索引节点不存储数据信息，因此一次性能够读入更多的关键字。
（2）增删文件效率更高，叶子节点存储数据，且使用有序列表相连，范围查询更加方便。
（3）B+树的查询效率更加稳定，所有关键字的查询路径长度相同。

<h3><span id="4-yu-hong-hei-shu-bi-jiao">4. 与红黑树比较</span><a href="#4-yu-hong-hei-shu-bi-jiao" class="header-anchor">#</a></h3><p>红黑树也可以用于索引，但是文件系统和数据可系统等普遍采用B+树进行索引，因为磁盘IO才是决定效率最大的因素，因此采用B+树这种矮胖的树更好。</p>
<h3><span id="5-b-shu-suo-yin-yu-hash-suo-yin-de-bi-jiao">5. B+树索引与hash索引的比较</span><a href="#5-b-shu-suo-yin-yu-hash-suo-yin-de-bi-jiao" class="header-anchor">#</a></h3><p>等值查询hash索引有绝对的优势，因为只需一次算法就能查找到键值。但是hash索引不支持范围查询。通过hash索引你也无法完成排序。</p>
<p>B+树索引支持范围查询，查询效率比较到平均。同时hash索引在有大量重复键值时，效率也很低，因为会发生哈希碰撞问题。<br>例如对性别关键字使用hash索引就非常不合理。</p>
<h2><span id="mysql-suo-yin">MySQL 索引</span><a href="#mysql-suo-yin" class="header-anchor">#</a></h2><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<h3><span id="1-b-tree-suo-yin">1. B+Tree 索引</span><a href="#1-b-tree-suo-yin" class="header-anchor">#</a></h3><p>是大多数 MySQL 存储引擎的默认索引类型。</p>
<p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p>
<p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p>
<p>可以指定多个列作为索引列，多个索引列共同组成键。</p>
<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<div align="center"> <img src="/pics/45016e98-6879-4709-8569-262b2d6d60b9.png" width="350px"> </div><br>
辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

<div align="center"> <img src="/pics/7c349b91-050b-4d72-a7f8-ec86320307ea.png" width="350px"> </div><br>
### 2. 哈希索引

<p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>
<ul>
<li>无法用于排序与分组；</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
</ul>
<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h3><span id="3-quan-wen-suo-yin">3. 全文索引</span><a href="#3-quan-wen-suo-yin" class="header-anchor">#</a></h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>
<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h3><span id="4-kong-jian-shu-ju-suo-yin">4. 空间数据索引</span><a href="#4-kong-jian-shu-ju-suo-yin" class="header-anchor">#</a></h3><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h2><span id="ju-ji-suo-yin-he-fei-ju-ji-suo-yin-wu-li-jiao-du-fen-xi">聚集索引和非聚集索引（物理角度分析）</span><a href="#ju-ji-suo-yin-he-fei-ju-ji-suo-yin-wu-li-jiao-du-fen-xi" class="header-anchor">#</a></h2><p>聚集索引只能存在一个，主键建立聚集索引，叶子节点存放数据页的位置。<br>非聚集索引中不存放数据位置，而是存放对应的主键。得到主键之后还需要在聚集索引上再查询一次。</p>
<h2><span id="suo-yin-de-you-dian">索引的优点</span><a href="#suo-yin-de-you-dian" class="header-anchor">#</a></h2><ul>
<li><p>大大减少了服务器需要扫描的数据行数。</p>
</li>
<li><p>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</p>
</li>
<li><p>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</p>
</li>
</ul>
<h2><span id="suo-yin-de-shi-yong-tiao-jian">索引的使用条件</span><a href="#suo-yin-de-shi-yong-tiao-jian" class="header-anchor">#</a></h2><ul>
<li><p>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</p>
</li>
<li><p>对于中到大型的表，索引就非常有效；</p>
</li>
<li><p>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</p>
</li>
</ul>
<h2><span id="suo-yin-you-hua">索引优化</span><a href="#suo-yin-you-hua" class="header-anchor">#</a></h2><h3><span id="1-du-li-de-lie">1. 独立的列</span><a href="#1-du-li-de-lie" class="header-anchor">#</a></h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>
<p>例如下面的查询不能使用 actor_id 列的索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="2-duo-lie-suo-yin">2. 多列索引</span><a href="#2-duo-lie-suo-yin" class="header-anchor">#</a></h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ <span class="keyword">id</span> <span class="keyword">FROM</span> sakila.film_actor</span><br><span class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span> <span class="keyword">AND</span> film_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="3-suo-yin-lie-de-shun-xu">3. 索引列的顺序</span><a href="#3-suo-yin-lie-de-shun-xu" class="header-anchor">#</a></h3><p>让选择性最强的索引列放在前面。</p>
<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure>

<h3><span id="4-qian-zhui-suo-yin">4. 前缀索引</span><a href="#4-qian-zhui-suo-yin" class="header-anchor">#</a></h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>
<p>前缀长度的选取需要根据索引选择性来确定。</p>
<h3><span id="5-fu-gai-suo-yin">5. 覆盖索引</span><a href="#5-fu-gai-suo-yin" class="header-anchor">#</a></h3><p>索引包含所有需要查询的字段的值。</p>
<p>具有以下优点：</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>
<h1><span id="er-cha-xun-xing-neng-you-hua">二、查询性能优化</span><a href="#er-cha-xun-xing-neng-you-hua" class="header-anchor">#</a></h1><h2><span id="shi-yong-explain-jin-xing-fen-xi">使用 Explain 进行分析</span><a href="#shi-yong-explain-jin-xing-fen-xi" class="header-anchor">#</a></h2><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>比较重要的字段有：</p>
<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引</li>
<li>rows : 扫描的行数</li>
</ul>
<h2><span id="you-hua-shu-ju-fang-wen">优化数据访问</span><a href="#you-hua-shu-ju-fang-wen" class="header-anchor">#</a></h2><h3><span id="1-jian-shao-qing-qiu-de-shu-ju-liang">1. 减少请求的数据量</span><a href="#1-jian-shao-qing-qiu-de-shu-ju-liang" class="header-anchor">#</a></h3><ul>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
<h3><span id="2-jian-shao-fu-wu-qi-duan-sao-miao-de-xing-shu">2. 减少服务器端扫描的行数</span><a href="#2-jian-shao-fu-wu-qi-duan-sao-miao-de-xing-shu" class="header-anchor">#</a></h3><p>最有效的方式是使用索引来覆盖查询。</p>
<h2><span id="chong-gou-cha-xun-fang-shi">重构查询方式</span><a href="#chong-gou-cha-xun-fang-shi" class="header-anchor">#</a></h2><h3><span id="1-qie-fen-da-cha-xun">1. 切分大查询</span><a href="#1-qie-fen-da-cha-xun" class="header-anchor">#</a></h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> messages <span class="keyword">WHERE</span> <span class="keyword">create</span> &lt; <span class="keyword">DATE_SUB</span>(<span class="keyword">NOW</span>(), <span class="built_in">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rows_affected = 0</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    rows_affected = do_query(</span><br><span class="line">    <span class="string">"DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000"</span>)</span><br><span class="line">&#125; <span class="keyword">while</span> rows_affected &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-fen-jie-da-lian-jie-cha-xun">2. 分解大连接查询</span><a href="#2-fen-jie-da-lian-jie-cha-xun" class="header-anchor">#</a></h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tab</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id=tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id=post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag=<span class="string">'mysql'</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag=<span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id=<span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure>

<h1><span id="san-cun-chu-yin-qing">三、存储引擎</span><a href="#san-cun-chu-yin-qing" class="header-anchor">#</a></h1><h2><span id="innodb">InnoDB</span><a href="#innodb" class="header-anchor">#</a></h2><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>
<p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。</p>
<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<h2><span id="myisam">MyISAM</span><a href="#myisam" class="header-anchor">#</a></h2><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
<p>不支持事务。</p>
<p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p>
<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p>
<p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>
<h2><span id="bi-jiao">比较</span><a href="#bi-jiao" class="header-anchor">#</a></h2><ul>
<li><p>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</p>
</li>
<li><p>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</p>
</li>
<li><p>外键：InnoDB 支持外键。</p>
</li>
<li><p>备份：InnoDB 支持在线热备份。</p>
</li>
<li><p>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</p>
</li>
<li><p>其它特性：MyISAM 支持压缩表和空间数据索引。</p>
</li>
</ul>
<h1><span id="si-shu-ju-lei-xing">四、数据类型</span><a href="#si-shu-ju-lei-xing" class="header-anchor">#</a></h1><h2><span id="zheng-xing">整型</span><a href="#zheng-xing" class="header-anchor">#</a></h2><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p>
<p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p>
<h2><span id="fu-dian-shu">浮点数</span><a href="#fu-dian-shu" class="header-anchor">#</a></h2><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p>
<p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p>
<h2><span id="zi-fu-chuan">字符串</span><a href="#zi-fu-chuan" class="header-anchor">#</a></h2><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p>
<p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p>
<p>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p>
<h2><span id="shi-jian-he-ri-qi">时间和日期</span><a href="#shi-jian-he-ri-qi" class="header-anchor">#</a></h2><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p>
<h3><span id="1-datetime">1. DATETIME</span><a href="#1-datetime" class="header-anchor">#</a></h3><p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p>
<p>它与时区无关。</p>
<p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22<span>:</span>37<span>:</span>08”，这是 ANSI 标准定义的日期和时间表示方法。</p>
<h3><span id="2-timestamp">2. TIMESTAMP</span><a href="#2-timestamp" class="header-anchor">#</a></h3><p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。</p>
<p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p>
<p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p>
<p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p>
<p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p>
<h1><span id="wu-fen-ku-fen-biao">五、分库分表</span><a href="#wu-fen-ku-fen-biao" class="header-anchor">#</a></h1><p>1、随着单库中的数据量越来越大，相应的，查询所需要的时间也越来越多，这个时候，相当于数据的处理遇到了瓶颈<br>2、单库发生意外的时候，需要修复的是所有的数据，而多库中的一个库发生意外的时候，只需要修复一个库（当然，也可以用物理分区的方式处理这种问题）</p>
<h2><span id="chui-zhi-qie-fen">垂直切分</span><a href="#chui-zhi-qie-fen" class="header-anchor">#</a></h2><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>
<p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p>
<div align="center"> <img src="/pics/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg" width> </div><br>
## 水平切分

<p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p>
<p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p>
<div align="center"> <img src="/pics/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg" width> </div><br>

<h2><span id="shui-ping-qie-fen-ce-lue">水平切分策略</span><a href="#shui-ping-qie-fen-ce-lue" class="header-anchor">#</a></h2><ul>
<li>哈希取模：hash(key) % N；</li>
<li>范围：可以是 ID 范围也可以是时间范围；</li>
<li>映射表：使用单独的一个数据库来存储映射关系。</li>
</ul>
<h2><span id="sharding-cun-zai-de-wen-ti">Sharding 存在的问题</span><a href="#sharding-cun-zai-de-wen-ti" class="header-anchor">#</a></h2><h3><span id="1-shi-wu-wen-ti">1. 事务问题</span><a href="#1-shi-wu-wen-ti" class="header-anchor">#</a></h3><p>使用分布式事务来解决，比如 XA 接口。</p>
<h3><span id="2-lian-jie">2. 连接</span><a href="#2-lian-jie" class="header-anchor">#</a></h3><p>可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</p>
<h3><span id="3-id-wei-yi-xing">3. ID 唯一性</span><a href="#3-id-wei-yi-xing" class="header-anchor">#</a></h3><p>保证ID全局唯一性，主要包括两个要求：<br>1）全局唯一性：不能出现重复的ID号。<br>2）数据递增：保证下一ID号一定大于上一个ID号。</p>
<ul>
<li>使用全局唯一 ID（UUID，GUID是UUID的一种实现): 使用uuid作为主键是最简单的方案，缺点也很明显，uuid长度太长，占据的空间比较大，作为索引并且基于索引的查询性能上面会有一定的影响。</li>
<li>为每个分片指定一个 ID 范围</li>
<li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法):其主要算法的核心就是生成long型的ID,共64位，第一位未使用，41bit的毫秒级时间，5bitdatacenter标志位，5bit机器码，12bit作为毫秒内序列号。该算法每秒能产生26万个id</li>
</ul>
<h1><span id="liu-fu-zhi">六、复制</span><a href="#liu-fu-zhi" class="header-anchor">#</a></h1><h2><span id="zhu-cong-fu-zhi">主从复制</span><a href="#zhu-cong-fu-zhi" class="header-anchor">#</a></h2><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li>
<li><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li>
<li><strong>SQL 线程</strong> ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li>
</ul>
<div align="center"> <img src="/pics/master-slave.png" width> </div><br>
## 读写分离

<p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p>读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>
<div align="center"> <img src="/pics/master-slave-proxy.png" width> </div><br>
# 七、备份
冷备份（停机备份）
冷备份发生在数据库已经关闭的情况下，数据库关闭之后会提供一个完整的数据库，只需要将关键的文件拷贝到另一个位置上。对于数据库来说冷备份是最快和最安全的方法。

<p>冷备份优点：</p>
<ul>
<li>速度快，只需拷贝文件</li>
<li>容易归档</li>
<li>容易恢复</li>
<li>低度维护，高度安全</li>
</ul>
<p>冷备份的缺点：</p>
<ul>
<li>单独使用时，只提供”某一时间点”的恢复</li>
<li>冷备份过程中，数据库不能工作</li>
<li>若磁盘空间有限，拷贝到其他外部存储设备，速度会很慢</li>
<li>不能按表，按用户进行恢复</li>
</ul>
<p>热备份：<br>热备份是指在数据库运行时，备份数据库的sql语句，当数据库发生问题时，重新执行一遍备份的sql语句。</p>
<p>优点：</p>
<ul>
<li>可以在表空间和数据文件级备份，备份时间短</li>
<li>备份时数据库可用</li>
<li>可以达到秒级恢复（精确恢复到某一时间点上）</li>
<li>可以对所有数据库实体进行恢复</li>
<li>大多数情况下，可以在数据库工作时进行回复</li>
</ul>
<p>缺点：</p>
<ul>
<li>备份不能出错，否则后果严重</li>
<li>难以维护，不允许以失败而告终</li>
<li>热备份不成功的话，结果用于恢复</li>
</ul>
<h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul>
<li>BaronScbwartz, PeterZaitsev, VadimTkacbenko, 等. 高性能 MySQL[M]. 电子工业出版社, 2013.</li>
<li>姜承尧. MySQL 技术内幕: InnoDB 存储引擎 [M]. 机械工业出版社, 2011.</li>
<li><a href="https://www.jfox.info/20-tiao-mysql-xing-nen-you-hua-de-zui-jia-jing-yan.html" target="_blank" rel="noopener">20+ 条 MySQL 性能优化的最佳经验</a></li>
<li><a href="http://blog.720ui.com/2017/mysql_core_09_multi_db_table2/" target="_blank" rel="noopener" title="服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策">服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策</a></li>
<li><a href="https://stackoverflow.com/questions/788829/how-to-create-unique-row-id-in-sharded-databases" target="_blank" rel="noopener">How to create unique row ID in sharded databases?</a></li>
<li><a href="http://geekswithblogs.net/shaunxu/archive/2012/01/07/sql-azure-federation-ndash-introduction.aspx" target="_blank" rel="noopener" title="Title of this entry.">SQL Azure Federation – Introduction</a></li>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL 索引背后的数据结构及算法原理</a></li>
<li><a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener">MySQL 性能优化神器 Explain 使用分析</a></li>
<li><a href="https://medium.com/@jeeyoungk/how-sharding-works-b4dec46b3f6" target="_blank" rel="noopener">How Sharding Works</a></li>
<li><a href="https://tech.meituan.com/dianping_order_db_sharding.html" target="_blank" rel="noopener">大众点评订单系统分库分表实践</a></li>
<li><a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91" target="_blank" rel="noopener">B + 树</a></li>
</ul>
<p><br><div align="center">💡 <br><br> 更多精彩内容将发布在公众号 <strong>CyC2018</strong>，公众号提供了该项目的离线阅读版本，后台回复”下载” 即可领取。也提供了一份技术面试复习思维导图，不仅系统整理了面试知识点，而且标注了各个知识点的重要程度，从而帮你理清多而杂的面试知识点，后台回复”资料” 即可领取。我基本是按照这个思维导图来进行复习的，对我拿到了 BAT 头条等 Offer 起到很大的帮助。你们完全可以和我一样根据思维导图上列的知识点来进行复习，就不用看很多不重要的内容，也可以知道哪些内容很重要从而多安排一些复习时间。</div><br></p>
<div align="center"><img width="180px" src="https://cyc-1256109796.cos.ap-guangzhou.myqcloud.com/%E5%85%AC%E4%BC%97%E5%8F%B7.jpg"></div>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Java%E5%9F%BA%E7%A1%80/Java/Java_IO/" rel="prev" title="Java_IO">
      <i class="fa fa-chevron-left"></i> Java_IO
    </a></div>
      <div class="post-nav-item">
    <a href="/uncategorized/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" rel="next" title="数据库/Redis">
      数据库/Redis <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">1.</span> <span class="nav-text">一、索引#</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.1.</span> <span class="nav-text">B+ Tree 原理#</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.2.</span> <span class="nav-text">MySQL 索引#</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.3.</span> <span class="nav-text">聚集索引和非聚集索引（物理角度分析）#</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.4.</span> <span class="nav-text">索引的优点#</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.5.</span> <span class="nav-text">索引的使用条件#</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.6.</span> <span class="nav-text">索引优化#</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">2.</span> <span class="nav-text">二、查询性能优化#</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">2.1.</span> <span class="nav-text">使用 Explain 进行分析#</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">2.2.</span> <span class="nav-text">优化数据访问#</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">2.3.</span> <span class="nav-text">重构查询方式#</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">3.</span> <span class="nav-text">三、存储引擎#</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">3.1.</span> <span class="nav-text">InnoDB#</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">3.2.</span> <span class="nav-text">MyISAM#</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">3.3.</span> <span class="nav-text">比较#</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">4.</span> <span class="nav-text">四、数据类型#</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">4.1.</span> <span class="nav-text">整型#</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">4.2.</span> <span class="nav-text">浮点数#</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">4.3.</span> <span class="nav-text">字符串#</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">4.4.</span> <span class="nav-text">时间和日期#</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">5.</span> <span class="nav-text">五、分库分表#</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">5.1.</span> <span class="nav-text">垂直切分#</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">5.2.</span> <span class="nav-text">水平切分策略#</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">5.3.</span> <span class="nav-text">Sharding 存在的问题#</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">6.</span> <span class="nav-text">六、复制#</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.1.</span> <span class="nav-text">主从复制#</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">7.</span> <span class="nav-text">参考资料#</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="DXQ"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">DXQ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DXQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">210k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:11</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

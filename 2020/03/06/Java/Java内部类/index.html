<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cloud.png">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=EB Garamond:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"hide","padding":10,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/search.xml"};
  </script>

  <meta name="description" content="本文由 简悦 SimpRead 转码， 原文地址 https:&#x2F;&#x2F;blog.csdn.net&#x2F;hacker_zhidian&#x2F;article&#x2F;details&#x2F;82193100 版权声明：尊重作者劳动成果，转载请声明出处，谢谢！ https:&#x2F;&#x2F;blog.csdn.net&#x2F;Hacker_ZhiDian&#x2F;article&#x2F;details&#x2F;82193100     *本篇文章已授权微信公众号 guolin">
<meta property="og:type" content="article">
<meta property="og:title" content="Java&#x2F;Java内部类">
<meta property="og:url" content="http://yoursite.com/2020/03/06/Java/Java%E5%86%85%E9%83%A8%E7%B1%BB/index.html">
<meta property="og:site_name" content="欢迎来到我的博客！">
<meta property="og:description" content="本文由 简悦 SimpRead 转码， 原文地址 https:&#x2F;&#x2F;blog.csdn.net&#x2F;hacker_zhidian&#x2F;article&#x2F;details&#x2F;82193100 版权声明：尊重作者劳动成果，转载请声明出处，谢谢！ https:&#x2F;&#x2F;blog.csdn.net&#x2F;Hacker_ZhiDian&#x2F;article&#x2F;details&#x2F;82193100     *本篇文章已授权微信公众号 guolin">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdn.net/20181022125507774?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180829222924401?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/2018082922581233?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180829232517151?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180830215803663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180830223317248?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180830224707413?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180903231653703?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180903231757126?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180903232403696?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180903232530936?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180903232732610?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180903233158416?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/2018090323324055?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180903233328504?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180903233538623?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180903235328653?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="article:published_time" content="2020-03-06T10:52:57.127Z">
<meta property="article:modified_time" content="2019-10-28T12:21:47.582Z">
<meta property="article:author" content="DXQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdn.net/20181022125507774?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">

<link rel="canonical" href="http://yoursite.com/2020/03/06/Java/Java%E5%86%85%E9%83%A8%E7%B1%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

<!-- jquery -->

<script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <title>Java/Java内部类 | 欢迎来到我的博客！</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">欢迎来到我的博客！</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/06/Java/Java%E5%86%85%E9%83%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="DXQ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到我的博客！">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java/Java内部类
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-06 18:52:57" itemprop="dateCreated datePublished" datetime="2020-03-06T18:52:57+08:00">2020-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-28 20:21:47" itemprop="dateModified" datetime="2019-10-28T20:21:47+08:00">2019-10-28</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://blog.csdn.net/hacker_zhidian/article/details/82193100" target="_blank" rel="noopener">https://blog.csdn.net/hacker_zhidian/article/details/82193100</a> 版权声明：尊重作者劳动成果，转载请声明出处，谢谢！ <a href="https://blog.csdn.net/Hacker_ZhiDian/article/details/82193100" target="_blank" rel="noopener">https://blog.csdn.net/Hacker_ZhiDian/article/details/82193100</a> <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-cd6c485e8b.css">  </p>
</blockquote>
<p><code>*本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</code></p>
<h3><span id="wen-zhang-mu-lu">文章目录</span><a href="#wen-zhang-mu-lu" class="header-anchor">#</a></h3><ul>
<li><p><a href="#_3">前言</a></p>
</li>
<li><p><a href="#_7">普通内部类</a></p>
</li>
<li><p><a href="#_66">静态内部类</a></p>
</li>
<li><p><a href="#_111">匿名内部类</a></p>
</li>
<li><p><a href="#_173">局部内部类</a></p>
</li>
<li><p><a href="#_227">内部类的嵌套</a></p>
</li>
<li><p><a href="#_237">深入理解内部类</a></p>
</li>
<li><p><a href="#_294">内部类和多重继承</a></p>
</li>
<li><p><a href="#_346">内部类和内存泄露</a></p>
</li>
</ul>
<h2><span id="qian-yan">前言</span><a href="#qian-yan" class="header-anchor">#</a></h2><p>内部类在 Java 里面算是非常常见的一个功能了，在日常开发中我们肯定多多少少都用过，这里总结一下关于 Java 中内部类的相关知识点和一些使用内部类时需要注意的点。<br>从种类上说，内部类可以分为四类：普通内部类、静态内部类、匿名内部类、局部内部类。我们来一个个看：</p>
<h4><span id="pu-tong-nei-bu-lei">普通内部类</span><a href="#pu-tong-nei-bu-lei" class="header-anchor">#</a></h4><p>这个是最常见的内部类之一了，其定义也很简单，在一个类里面作为类的一个字段直接定义就可以了，例：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">InnerClassTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">InnerClassA</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里 <code>InnerClassA</code> 类为 <code>InnerClassTest</code> 类的普通内部类，在这种定义方式下，<strong>普通内部类对象依赖外部类对象而存在</strong>，即在创建一个普通内部类对象时首先需要创建其外部类对象，我们在创建上面代码中的 <code>InnerClassA</code> 对象时先要创建 <code>InnerClassTest</code> 对象，例：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> outField1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> outField2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> outField3 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> outField4 = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerClassTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在外部类对象内部，直接通过 new InnerClass(); 创建内部类对象</span></span><br><span class="line">        InnerClassA innerObj = <span class="keyword">new</span> InnerClassA();</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"创建 "</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" 对象"</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"其内部类的 field1 字段的值为: "</span> + innerObj.field1);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"其内部类的 field2 字段的值为: "</span> + innerObj.field2);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"其内部类的 field3 字段的值为: "</span> + innerObj.field3);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"其内部类的 field4 字段的值为: "</span> + innerObj.field4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassA</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> field1 = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> field2 = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span> field3 = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> field4 = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//        static int field5 = 5; // 编译错误！普通内部类中不能定义 static 属性</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClassA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"创建 "</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" 对象"</span>);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"其外部类的 outField1 字段的值为: "</span> + outField1);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"其外部类的 outField2 字段的值为: "</span> + outField2);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"其外部类的 outField3 字段的值为: "</span> + outField3);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"其外部类的 outField4 字段的值为: "</span> + outField4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        InnerClassTest outerObj = <span class="keyword">new</span> InnerClassTest();</span><br><span class="line">        <span class="comment">// 不在外部类内部，使用：外部类对象. new 内部类构造器(); 的方式创建内部类对象</span></span><br><span class="line"><span class="comment">//        InnerClassA innerObj = outerObj.new InnerClassA();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的内部类就像外部类声明的一个属性字段一样，因此其的对象时依附于外部类对象而存在的，我们来看一下结果：<br><img src="https://img-blog.csdn.net/20181022125507774?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>我们注意到，内部类对象可以访问外部类对象中所有访问权限的字段，同时，外部类对象也可以通过内部类的对象引用来访问内部类中定义的所有访问权限的字段，后面我们将从源码里面分析具体的原因。<br>我们下面来看一下静态内部类：</p>
<h4><span id="jing-tai-nei-bu-lei">静态内部类</span><a href="#jing-tai-nei-bu-lei" class="header-anchor">#</a></h4><p>我们知道，一个类的静态成员独立于这个类的任何一个对象存在，只要在具有访问权限的地方，我们就可以通过 <code>类名.静态成员名</code> 的形式来访问这个静态成员，同样的，静态内部类也是作为一个外部类的静态成员而存在，<strong>创建一个类的静态内部类对象不需要依赖其外部类对象</strong>。例：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> field1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InnerClassTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"创建 "</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" 对象"</span>);</span><br><span class="line">        <span class="comment">// 创建静态内部类对象</span></span><br><span class="line">        StaticClass innerObj = <span class="keyword">new</span> StaticClass();</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"其内部类的 field1 字段的值为: "</span> + innerObj.field1);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"其内部类的 field2 字段的值为: "</span> + innerObj.field2);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"其内部类的 field3 字段的值为: "</span> + innerObj.field3);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"其内部类的 field4 字段的值为: "</span> + innerObj.field4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticClass</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> field1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> field2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> field3 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> field4 = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// 静态内部类中可以定义 static 属性</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> field5 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StaticClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"创建 "</span> + StaticClass.class.getSimpleName() + <span class="string">" 对象"</span>);</span><br><span class="line"><span class="comment">//            System.out.println("其外部类的 field1 字段的值为: " + field1); // 编译错误！！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">// 无需依赖外部类对象，直接创建内部类对象</span></span><br><span class="line"><span class="comment">//        InnerClassTest.StaticClass staticClassObj = new InnerClassTest.StaticClass();</span></span><br><span class="line">		InnerClassTest outerObj = <span class="keyword">new</span> InnerClassTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<br><img src="https://img-blog.csdn.net/20180829222924401?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p>可以看到，静态内部类就像外部类的一个静态成员一样，创建其对象无需依赖外部类对象（访问一个类的静态成员也无需依赖这个类的对象，因为它是独立于所有类的对象的）。但是于此同时，静态内部类中也无法访问外部类的<strong>非静态成员</strong>，因为外部类的非静态成员是属于每一个外部类对象的，而本身静态内部类就是独立外部类对象存在的，所以静态内部类不能访问外部类的非静态成员，而外部类依然可以访问静态内部类对象的所有访问权限的成员，这一点和普通内部类无异。</p>
<h4><span id="ni-ming-nei-bu-lei">匿名内部类</span><a href="#ni-ming-nei-bu-lei" class="header-anchor">#</a></h4><p>匿名内部类有多种形式，其中最常见的一种形式莫过于在方法参数中新建一个接口对象 / 类对象，并且实现这个接口声明 / 类中原有的方法了：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InnerClassTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> field1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> field2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> field3 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> field4 = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerClassTest</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"创建 "</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" 对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义接口</span></span><br><span class="line">	<span class="keyword">interface</span> <span class="title">OnClickListener</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onClick</span>(<span class="params">Object obj</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anonymousClassTest</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这个过程中会新建一个匿名内部类对象，</span></span><br><span class="line">        <span class="comment">// 这个匿名内部类实现了 OnClickListener 接口并重写 onClick 方法</span></span><br><span class="line">        OnClickListener clickListener = <span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">	        <span class="comment">// 可以在内部类中定义属性，但是只能在当前内部类中使用，</span></span><br><span class="line">	        <span class="comment">// 无法在外部类中使用，因为外部类无法获取当前匿名内部类的类名，</span></span><br><span class="line">	        <span class="comment">// 也就无法创建匿名内部类的对象</span></span><br><span class="line">	        <span class="keyword">int</span> field = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span>(<span class="params">Object obj</span>)</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"对象 "</span> + obj + <span class="string">" 被点击"</span>);</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"其外部类的 field1 字段的值为: "</span> + field1);</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"其外部类的 field2 字段的值为: "</span> + field2);</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"其外部类的 field3 字段的值为: "</span> + field3);</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"其外部类的 field4 字段的值为: "</span> + field4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// new Object() 过程会新建一个匿名内部类，继承于 Object 类，</span></span><br><span class="line">        <span class="comment">// 并重写了 toString() 方法</span></span><br><span class="line">        clickListener.onClick(<span class="keyword">new</span> Object() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"obj1"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        InnerClassTest outObj = <span class="keyword">new</span> InnerClassTest();</span><br><span class="line">        outObj.anonymousClassTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看看结果：<br><img src="https://img-blog.csdn.net/2018082922581233?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>上面的代码中展示了常见的两种使用匿名内部类的情况：<br>1、直接 new 一个接口，并实现这个接口声明的方法，在这个过程其实会创建一个匿名内部类实现这个接口，并重写接口声明的方法，然后再创建一个这个匿名内部类的对象并赋值给前面的 <code>OnClickListener</code> 类型的引用；<br>2、new 一个已经存在的类 / 抽象类，并且选择性的实现这个类中的一个或者多个<strong>非 final</strong> 的方法，这个过程会创建一个匿名内部类对象继承对应的类 / 抽象类，并且重写对应的方法。</p>
<p>同样的，在匿名内部类中可以使用外部类的属性，但是外部类却不能使用匿名内部类中定义的属性，因为是匿名内部类，因此在外部类中无法获取这个类的类名，也就无法得到属性信息。</p>
<h4><span id="ju-bu-nei-bu-lei">局部内部类</span><a href="#ju-bu-nei-bu-lei" class="header-anchor">#</a></h4><p>局部内部类使用的比较少，其声明在一个方法体 / 一段代码块的内部，而且不在定义类的定义域之内便无法使用，其提供的功能使用匿名内部类都可以实现，而本身匿名内部类可以写得比它更简洁，因此局部内部类用的比较少。来看一个局部内部类的小例子：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> InnerClassTest &#123;</span><br><span class="line"></span><br><span class="line">    public <span class="built_in">int</span> field1 = <span class="number">1</span>;</span><br><span class="line">    protected <span class="built_in">int</span> field2 = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int</span> field3 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> field4 = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    public <span class="constructor">InnerClassTest()</span> &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"创建 "</span> + this.get<span class="constructor">Class()</span>.get<span class="constructor">SimpleName()</span> + <span class="string">" 对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void local<span class="constructor">InnerClassTest()</span> &#123;</span><br><span class="line">	    <span class="comment">// 局部内部类 A，只能在当前方法中使用</span></span><br><span class="line">        <span class="keyword">class</span> A &#123;</span><br><span class="line">	        <span class="comment">// static int field = 1; // 编译错误！局部内部类中不能定义 static 字段</span></span><br><span class="line">            public <span class="constructor">A()</span> &#123;</span><br><span class="line">	            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"创建 "</span> + <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">SimpleName()</span> + <span class="string">" 对象"</span>);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"其外部类的 field1 字段的值为: "</span> + field1);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"其外部类的 field2 字段的值为: "</span> + field2);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"其外部类的 field3 字段的值为: "</span> + field3);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"其外部类的 field4 字段的值为: "</span> + field4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        A a = <span class="keyword">new</span> <span class="constructor">A()</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	        <span class="comment">// 局部内部类 B，只能在当前代码块中使用</span></span><br><span class="line">            <span class="keyword">class</span> B &#123;</span><br><span class="line">                public <span class="constructor">B()</span> &#123;</span><br><span class="line">	                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"创建 "</span> + <span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">SimpleName()</span> + <span class="string">" 对象"</span>);</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"其外部类的 field1 字段的值为: "</span> + field1);</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"其外部类的 field2 字段的值为: "</span> + field2);</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"其外部类的 field3 字段的值为: "</span> + field3);</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"其外部类的 field4 字段的值为: "</span> + field4);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            B b = <span class="keyword">new</span> <span class="constructor">B()</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        B b1 = new B(); // 编译错误！不在类 B 的定义域内，找不到类 B，</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        InnerClassTest outObj = <span class="keyword">new</span> <span class="constructor">InnerClassTest()</span>;</span><br><span class="line">        outObj.local<span class="constructor">InnerClassTest()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，在局部内部类里面可以访问外部类对象的所有访问权限的字段，而外部类却不能访问局部内部类中定义的字段，因为局部内部类的定义只在其特定的方法体 / 代码块中有效，一旦出了这个定义域，那么其定义就失效了，就像代码注释中描述的那样，即外部类不能获取局部内部类的对象，因而无法访问局部内部类的字段。最后看看运行结果：<br><img src="https://img-blog.csdn.net/20180829232517151?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<h4><span id="nei-bu-lei-de-qian-tao">内部类的嵌套</span><a href="#nei-bu-lei-de-qian-tao" class="header-anchor">#</a></h4><p>内部类的嵌套，即为内部类中再定义内部类，这个问题从内部类的分类角度去考虑比较合适：<br>普通内部类：在这里我们可以把它看成一个外部类的普通成员方法，在其内部可以定义普通内部类（嵌套的普通内部类），但是无法定义 <code>static</code> 修饰的内部类，就像你无法在成员方法中定义 <code>static</code> 类型的变量一样，当然也可以定义匿名内部类和局部内部类；</p>
<p>静态内部类：因为这个类独立于外部类对象而存在，我们完全可以将其拿出来，去掉修饰它的 <code>static</code> 关键字，他就是一个完整的类，因此在静态内部类内部可以定义普通内部类，也可以定义静态内部类，同时也可以定义 <code>static</code> 成员；</p>
<p>匿名内部类：和普通内部类一样，定义的普通内部类只能在这个匿名内部类中使用，定义的局部内部类只能在对应定义域内使用；</p>
<p>局部内部类：和匿名内部类一样，但是嵌套定义的内部类只能在对应定义域内使用。</p>
<h4><span id="shen-ru-li-jie-nei-bu-lei">深入理解内部类</span><a href="#shen-ru-li-jie-nei-bu-lei" class="header-anchor">#</a></h4><p>不知道小伙伴们对上面的代码有没有产生疑惑：非静态内部类可以访问外部类所有访问权限修饰的字段（即包括了 <code>private</code> 权限的），同时，外部类也可以访问内部类的所有访问权限修饰的字段。而我们知道，<code>private</code> 权限的字段只能被当前类本身访问。然而在上面我们确实在代码中直接访问了对应外部类 / 内部类的 <code>private</code> 权限的字段，要解除这个疑惑，只能从编译出来的类下手了，为了简便，这里采用下面的代码进行测试：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">InnerClassTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> field1 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">int</span> field2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> InnerClassTest() &#123;</span><br><span class="line">		InnerClassA inner = new InnerClassA();</span><br><span class="line">		<span class="built_in">int</span> v = inner.x2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">InnerClassA</span> &#123;</span><br><span class="line">		<span class="built_in">int</span> x1 = field1;</span><br><span class="line">		<span class="keyword">private</span> <span class="built_in">int</span> x2 = field2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在外部类中定义了一个默认访问权限（同一个包内的类可以访问）的字段 <code>field1</code>， 和一个 <code>private</code> 权限的字段 <code>field2</code> ，并且定义了一个内部类 <code>InnerClassA</code> ，并且在这个内部类中也同样定义了两个和外部类中定义的相同修饰权限的字段，并且访问了外部类对应的字段。最后在外部类的构造方法中我定义了一个方法内变量赋值为内部类中 <code>private</code> 权限的字段。我们用 <code>javac</code> 命令（<code>javac InnerClassTest.java</code>）编译这个 <code>.java</code> 文件，会得到两个 <code>.classs</code> 文件：<br><code>InnerClassTest.class</code> 和 <code>InnerClassTest$InnerClassA.class</code>，我们再用 <code>javap -c</code> 命令（<code>javap -c InnerClassTest</code> 和 <code>javap -c InnerClassTest$InnerClassA</code>）分别反编译这两个 <code>.class</code> 文件，<code>InnerClassTest.class</code> 的字节码如下：</p>
<p><img src="https://img-blog.csdn.net/20180830215803663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>我们注意到字节码中多了一个默认修饰权限并且名为 <code>access$100</code> 的静态方法，其接受一个 <code>InnerClassTest</code> 类型的参数，即其接受一个外部类对象作为参数，方法内部用三条指令取到参数对象的 <code>field2</code> 字段的值并返回。由此，我们现在大概能猜到内部类对象是怎么取到外部类的 <code>private</code> 权限的字段了：就是通过这个外部类提供的静态方法。<br>类似的，我们注意到 24 行字节码指令 <code>invokestatic</code> ，这里代表执行了一个静态方法，而后面的注释也写的很清楚，调用的是 <code>InnerClassTest$InnerClassA.access$000</code> 方法，即调用了内部类中名为 <code>access$000</code> 的静态方法，根据我们上面的外部类字节码规律，我们也能猜到这个方法就是内部类编译过程中编译器自动生成的，那么我们赶紧来看一下 <code>InnerClassTest$InnerClassA</code> 类的字节码吧：<br><img src="https://img-blog.csdn.net/20180830223317248?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>果然，我们在这里发现了名为 <code>access$000</code> 的静态方法，并且这个静态方法接受一个 <code>InnerClassTest$InnerClassA</code> 类型的参数，方法的作用也很简单：返回参数代表的内部类对象的 <code>x2</code> 字段值。<br>我们还注意到编译器给内部类提供了一个接受 <code>InnerClassTest</code> 类型对象（即外部类对象）的构造方法，内部类本身还定义了一个名为 <code>this$0</code> 的 <code>InnerClassTest</code> 类型的引用，这个引用在构造方法中指向了参数所对应的外部类对象。<br>最后，我们在 25 行字节码指令发现：内部类的构造方法通过 <code>invokestatic</code> 指令执行外部类的 <code>access$100</code> 静态方法（在 <code>InnerClassTest</code> 的字节码中已经介绍了）得到外部类对象的 <code>field2</code> 字段的值，并且在后面赋值给 <code>x2</code> 字段。这样的话内部类就成功的通过外部类提供的静态方法得到了对应外部类对象的 <code>field2</code> 。</p>
<p>上面我们只是对普通内部类进行了分析，但其实匿名内部类和局部内部类的原理和普通内部类是类似的，只是在访问上有些不同：外部类无法访问匿名内部类和局部内部类对象的字段，<strong>因为外部类根本就不知道匿名内部类 / 局部内部类的类型信息（匿名内部类的类名被隐匿，局部内部类只能在定义域内使用）</strong>。但是匿名内部类和局部内部类却可以访问外部类的私有成员，原理也是通过外部类提供的静态方法来得到对应外部类对象的私有成员的值。而对于静态内部类来说，因为其实独立于外部类对象而存在，因此编译器不会为静态内部类对象提供外部类对象的引用，因为静态内部类对象的创建根本不需要外部类对象支持。但是外部类对象还是可以访问静态内部类对象的私有成员，因为外部类可以知道静态内部类的类型信息，即可以得到静态内部类的对象，那么就可以通过静态内部类提供的静态方法来获得对应的私有成员值。来看一个简单的代码证明：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">InnerClassTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> field1 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">int</span> field2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> InnerClassTest() &#123;</span><br><span class="line">		InnerClassA inner = new InnerClassA();</span><br><span class="line">		<span class="built_in">int</span> v = inner.x2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里改成了静态内部类，因而不能访问外部类的非静态成员</span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">class</span> <span class="symbol">InnerClassA</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="built_in">int</span> x2 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的编译步骤，得到了两个 <code>.class</code> 文件，这里看一下内部类的 <code>.class</code> 文件反编译的字节码 <code>InnerClassTest$InnerClassA</code>：<br><img src="https://img-blog.csdn.net/20180830224707413?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>仔细看一下，确实没有找到指向外部类对象的引用，编译器只为这个静态内部类提供了一个无参构造方法。<br>而且因为外部类对象需要访问当前类的私有成员，编译器给这个静态内部类生成了一个名为 <code>access$000</code> 的静态方法，作用已不用我多说了。如果我们不看类名，这个类完全可以作为一个普通的外部类来看，这正是静态内部类和其余的内部类的区别所在：<strong>静态内部类对象不依赖其外部类对象存在，而其余的内部类对象必须依赖其外部类对象而存在</strong>。</p>
<p>OK，到这里问题都得到了解释：<strong>在非静态内部类访问外部类私有成员 / 外部类访问内部类私有成员 的时候，对应的外部类 / 外部类会生成一个静态方法，用来返回对应私有成员的值，而对应外部类对象 / 内部类对象通过调用其内部类 / 外部类提供的静态方法来获取对应的私有成员的值。</strong></p>
<h4><span id="nei-bu-lei-he-duo-chong-ji-cheng">内部类和多重继承</span><a href="#nei-bu-lei-he-duo-chong-ji-cheng" class="header-anchor">#</a></h4><p>我们已经知道，Java 中的类不允许多重继承，也就是说 Java 中的类只能有一个直接父类，而 Java 本身提供了内部类的机制，这是否可以在一定程度上弥补 Java 不允许多重继承的缺陷呢？我们这样来思考这个问题：假设我们有三个基类分别为 <code>A</code>、<code>B</code>、<code>C</code>，我们希望有一个类 <code>D</code> 达成这样的功能：通过这个 <code>D</code> 类的对象，可以同时产生 <code>A</code> 、<code>B</code> 、<code>C</code> 类的对象，通过刚刚的内部类的介绍，我们也应该想到了怎么完成这个需求了，创建一个类 <code>D.java</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 内部类，继承 B 类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">InnerClassB</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 内部类，继承 C 类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">InnerClassC</span> <span class="keyword">extends</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成一个 B 类对象</span></span><br><span class="line">	public <span class="type">B</span> makeB() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="type">InnerClassB</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成一个 C 类对象</span></span><br><span class="line">	public <span class="type">C</span> makeC() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="type">InnerClassC</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void testA(<span class="type">A</span> a) &#123;</span><br><span class="line">	    <span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void testB(<span class="type">B</span> b) &#123;</span><br><span class="line">	    <span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void testC(<span class="type">C</span> c) &#123;</span><br><span class="line">	    <span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">		<span class="type">D</span> d = <span class="keyword">new</span> <span class="type">D</span>();</span><br><span class="line">		testA(d);</span><br><span class="line">		testB(d.makeB());</span><br><span class="line">		testC(d.makeC());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序正确运行。而且因为普通内部类可以访问外部类的所有成员并且外部类也可以访问普通内部类的所有成员，因此这种方式在某种程度上可以说是 Java 多重继承的一种实现机制。但是这种方法也是有一定代价的，首先这种结构在一定程度上破坏了类结构，一般来说，建议一个 <code>.java</code> 文件只包含一个类，除非两个类之间有非常明确的依赖关系（比如说某种汽车和其专用型号的轮子），或者说一个类本来就是为了辅助另一个类而存在的（比如说上篇文章介绍的 <code>HashMap</code> 类和其内部用于遍历其元素的 <code>HashIterator</code> 类），那么这个时候使用内部类会有较好代码结构和实现效果。而在其他情况，将类分开写会有较好的代码可读性和代码维护性。</p>
<h4><span id="nei-bu-lei-he-nei-cun-xie-lu">内部类和内存泄露</span><a href="#nei-bu-lei-he-nei-cun-xie-lu" class="header-anchor">#</a></h4><p>在这一小节开始前介绍一下什么是内存泄露：即指在内存中存在一些其内存空间可以被回收的对象因为某些原因又没有被回收，因此产生了内存泄露，如果应用程序频繁发生内存泄露可能会产生很严重的后果（内存中可用的空间不足导致程序崩溃，甚至导致整个系统卡死）。<br>听起来怪吓人的，这个问题在一些需要开发者手动申请和释放内存的编程语言（C/C++）中会比较容易产生，因为开发者申请的内存需要手动释放，如果忘记了就会导致内存泄露，举个简单的例子（C++）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 申请一段内存，空间为 100 个 int 元素所占的字节数</span></span><br><span class="line">	<span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">	<span class="comment">// C++ 11</span></span><br><span class="line">	p = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码里我有意而为之：在为指针 p 申请完内存之后将其直接赋值为 <code>nullptr</code> ，这是 <code>C++ 11</code> 中一个表示空指针的关键字，我们平时常用的 NULL 只是一个值为 0 的常量值，在进行方法重载传参的时候可能会引起混淆。之后我直接返回了，虽然在程序结束之后操作系统会回收我们程序中申请的内存，但是不可否认的是上面的代码确实产生了内存泄露（申请的 100 个 int 元素所占的内存无法被回收）。这只是一个最简单不过的例子。我们在写这类程序的时候当动态申请的内存不再使用时，应该要主动释放申请的内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 申请一段内存，空间为 100 个 int 元素所占的字节数</span></span><br><span class="line">	<span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">	<span class="comment">// 释放 p 指针所指向的内存空间</span></span><br><span class="line">	<span class="keyword">delete</span>[] p;</span><br><span class="line">	<span class="comment">// C++ 11</span></span><br><span class="line">	p = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在 Java 中，因为 JVM 有垃圾回收功能，对于我们自己创建的对象无需手动回收这些对象的内存空间，这种机制确实在一定程度上减轻了开发者的负担，但是也增加了开发者对 JVM 垃圾回收机制的依赖性，从某个方面来说，也是弱化了开发者防止内存泄露的意识。当然，JVM 的垃圾回收机制的利是远远大于弊的，只是我们在开发过程中不应该丧失了这种对象和内存的意识。</p>
<p>回到正题，内部类和内存泄露又有什么关系呢？在继续阅读之前，请确保你对 JVM 的在进行垃圾回收时如何找出内存中不再需要的对象有一定的了解，如果你对这个过程不太了解，你可以参考一下 <a href="https://blog.csdn.net/Hacker_ZhiDian/article/details/81219657#finalize" target="_blank" rel="noopener">这篇文章</a> 中对这个过程的简单介绍。我们在上面已经知道了，创建非静态内部类的对象时，新建的非静态内部类对象会持有对外部类对象的引用，这个我们在上面的源码反编译中已经介绍过了，正是因为非静态内部类对象会持有外部类对象的引用，因此如果说这个非静态内部类对象因为某些原因无法被回收，就会导致这个外部类对象也无法被回收，这个听起来是有道理的，因为我们在上文也已经介绍了：非静态内部类对象依赖于外部类对象而存在，所以内部类对象没被回收，其外部类对象自然也不能被回收。但是可能存在这种情况：非静态内部类对象在某个时刻已经不在被使用，或者说这个内部类对象可以在不影响程序正确运行的情况下被回收，而因为我们对这个内部类的使用不当而使得其无法被 JVM 回收，同时会导致其外部类对象无法被回收，即为发生内存泄露。那么这个 “使用不当” 具体指的是哪个方面呢？看一个简单的例子，新建一个 <code>MemoryLeakTest</code> 的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeakTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象类，模拟一些组件的基类</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            onCreate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子类实现，模拟组件创建的过程</span></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子类实现，模拟组件摧毁的过程</span></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体某个组件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	    <span class="comment">// 组件中窗口的单击事件监听器</span></span><br><span class="line">        <span class="keyword">static</span> OnClickListener clickListener;</span><br><span class="line">        <span class="comment">// 模拟组件中的窗口</span></span><br><span class="line">        MyWindow myWindow;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 执行组件内一些资源初始化的代码</span></span><br><span class="line">            clickListener = <span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"对象 "</span> + obj + <span class="string">" 被单击"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 新建我的窗口对象，并设置其单击事件监听器</span></span><br><span class="line">            myWindow = <span class="keyword">new</span> MyWindow();</span><br><span class="line">            myWindow.setClickListener(clickListener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 执行组件内一些资源回收的代码</span></span><br><span class="line">            myWindow.removeClickListener();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我的窗口类，模拟一个可视化控件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWindow</span> </span>&#123;</span><br><span class="line">        OnClickListener clickListener;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置当前控件的单击事件监听器</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setClickListener</span><span class="params">(OnClickListener clickListener)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clickListener = clickListener;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除当前控件的单击事件监听器</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">removeClickListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clickListener = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的单击事件的监听接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyComponent myComponent = <span class="keyword">new</span> MyComponent();</span><br><span class="line">        myComponent.create();</span><br><span class="line">        myComponent.destroy();</span><br><span class="line">        <span class="comment">// myComponent 引用置为 null，排除它的干扰</span></span><br><span class="line">        myComponent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 调用 JVM 的垃圾回收动作，回收无用对象</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在代码中添加一些断点，然后采用 debug 模式查看：<br><img src="https://img-blog.csdn.net/20180903231653703?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>程序执行到 72 行代码，此时 72 行代码还未执行，因此 <code>myComponent</code> 引用和其对象还未创建，继续执行：<br><img src="https://img-blog.csdn.net/20180903231757126?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>这里成功创建了一个 <code>MyComponent</code> 对象，但是其 <code>create</code> 方法还未执行，所以 <code>myWindow</code> 字段为 null，这里可能有小伙伴会问了，<code>myComponent</code> 对象的 <code>clickListener</code> 字段呢？怎么不见了？其实这和我们在代码中定义 <code>clickListener</code> 字段的形式有关，我们定义的是 <code>static OnClickListener clickListener;</code> ，因此 <code>clickListener</code> 是一个静态字段，<strong>其在类加载的完成的时候储存在 JVM 中内存区域的 <code>方法区</code> 中，而创建的 Java 对象储存在 JVM 的堆内存中</strong>，两者不在同一块内存区域。关于这些细节，想深入了解的小伙伴建议阅读《深入理解 JVM 虚拟机》。好了，我们继续执行代码：<br><img src="https://img-blog.csdn.net/20180903232403696?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br><code>myComponent.create</code> 方法执行完成之后创建了 <code>OnClickListener</code> 内部类对象，并且为 <code>myWindow</code> 对象设置 <code>OnCLickListener</code> 单击事件监听。我们继续：<br><img src="https://img-blog.csdn.net/20180903232530936?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br><code>myComponent.destroy</code> 方法执行完成之后，<code>myWindow.removeClickListener</code> 方法也执行完成，此时 <code>myWindow</code> 对象中的 <code>clickListener</code> 字段为 null。我们继续：<br><img src="https://img-blog.csdn.net/20180903232732610?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>代码执行到了 80 行，在此之前，所有的代码和解释都没有什么难度，跟着运行图走，一切都那么顺利成章，其实这张图的运行结果也很好理解，只不过图中的文字需要思考一下：<code>myComponent</code> 引用指向的对象真的被回收了吗？要解答这个问题，我们需要借助 Java 中提供的内存分析工具 <code>jvisualvm</code> (以前它还不叫这个名字…），它一般在你安装 JDK 的目录下的 <code>bin</code> 子目录下：<br><img src="https://img-blog.csdn.net/20180903233158416?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>我们运行这个程序：<br><img src="https://img-blog.csdn.net/2018090323324055?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>在程序左边可以找到我们当前正在执行的 Java 进程，双击进入：<br><img src="https://img-blog.csdn.net/20180903233328504?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>单击 tab 中的 <code>监视</code> 选项卡，可以看到当前正在执行的 Java 进程的一些资源占用信息，当然我们现在的主要目的是分析内存，那么们单击右上角的 <code>堆 Dump</code> ：<br><img src="https://img-blog.csdn.net/20180903233538623?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>在这个界面，单击 <code>类</code> 选项卡，会出现当前 Java 进程中用到的所有的类，我们已经知道我们要查找的类的对象只创建了一个，因此我们根据右上角的 <code>实例数</code> 来进行排除：我们成功的找到了我们创建的对象！而这样也意味着当我们在上面代码中调用 JVM 的垃圾回收动作没有回收这三个对象，这其实就是一个真真切切的内存泄露！因为我们将 <code>main</code> 方法中的 <code>myComponent</code> 引用赋值为 null，就意味着我们已经不再使用这个组件和里面的一些子组件（<code>MyWindow</code> 对象），即这个组件和其内部的一些组件应该被回收。但是调用 JVM 的垃圾回收却并没有将其对应的对象回收。造成这个问题的原因在哪呢？<br>其实就在于我们刚刚在 <code>MyComponent</code> 类中定义的 <code>clickListener</code> 字段，我们在代码中将其定义成了 <code>static</code> 类型的，同时这个字段又指向了一个匿名内部类对象（在 <code>create</code> 方法中 创建了一个 <code>OnClickListener</code> 接口对象，即通过一个匿名内部类实现这个接口并创建其对象），根据 JVM 寻找和标记无用对象的规则（可达性分析算法），其会将 <code>clickListener</code> 字段作为一个 “root” ，并通过它来寻找还有用的对象，在这个例子中，<code>clickListener</code> 字段指向一个匿名内部类对象，这个匿名内部类对象有一个外部类对象（<code>MyComponent</code> 类型的对象）的引用，而外部类对象中又有一个 <code>MyWindow</code> 类型的对象引用。因此 JVM 会将这三个对象都视为有用的对象不会回收。用图来解释吧：<br><img src="https://img-blog.csdn.net/20180903235328653?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p>Ok，通过这个过程，相信你已经理解了造成此次内存泄露的原因了，那么我们该如何解决呢？对于当前这个例子，我们只需要改一些代码：<br>1、把 <code>MyComponent</code> 类中的 <code>clickListener</code> 字段前面的 <code>static</code> 修饰符去掉就可以了（<code>static OnClickListener clickListener;</code> -&gt; <code>OnClickListener clickListener;</code>），这样的话 <code>clickListener</code> 指向的对象，就作为 <code>MyComponent</code> 类的对象的一部分了，在 <code>MyComponent</code> 对象被回收时里面的子组件也会被回收。同时它们之间也只是互相引用（<code>MyComponent</code> 外部类对象中有一个指向 <code>OnClickListener</code> 内部类对象的引用，<code>OnClickListener</code> 内部类对象有一个指向 <code>MyComponent</code> 外部类对象的引用），根据 JVM 的 “可达性分析” 算法，在两个对象都不再被外部使用时，JVM 的垃圾回收机制是可以标记并回收这两个对象的。<br>虽然不强制要求你在 <code>MyComponent</code> 类中的 <code>onDestroy</code> 方法中将其 <code>clickListener</code> 引用赋值为 null，但是我还是建议你这样做，因为这样更能确保你的程序的安全性（减少发生内存泄露的机率，毕竟匿名内部类对象会持有外部类对象的引用），<strong>在某个组件被销毁时将其内部的一些子组件进行合理的处理是一个很好的习惯。</strong><br>2、你也可以自定义一个静态内部类或者是另外自定义一个类文件，并实现 <code>OnClickListener</code> 接口，之后通过这个类创建对象，这样就可以避免通过非静态内部类的形式创建 <code>OnClickListener</code> 对象增加内存泄露的可能性。</p>
<h5><span id="bi-mian-nei-cun-xie-lou">避免内存泄漏</span><a href="#bi-mian-nei-cun-xie-lou" class="header-anchor">#</a></h5><p>那么我们在日常开发中怎么合理的使用内部类来避免产生内存泄露呢？这里给出一点我个人的理解：<br>1、能用静态内部类就尽量使用静态内部类，从上文中我们也知道了，静态内部类的对象创建不依赖外部类对象，即静态内部对象不会持有外部类对象的引用，自然不会因为静态内部类对象而导致内存泄露，所以如果你的内部类中不需要访问外部类中的一些非 <code>static</code> 成员，那么请把这个内部类改造成静态内部类；</p>
<p>2、对于一些自定义类的对象，慎用 <code>static</code> 关键字修饰（除非这个类的对象的声明周期确实应该很长），我们已经知道，JVM 在进行垃圾回收时会将 <code>static</code> 关键字修饰的一些静态字段作为 “root” 来进行存活对象的查找，所以程序中 <code>static</code> 修饰的对象越多，对应的 “root” 也就越多，每一次 JVM 能回收的对象就越少。<br>当然这并不是建议你不使用 <code>static</code> 关键字，只是在使用这个关键字之前可以考虑一下这个对象使用 <code>static</code> 关键字修饰对程序的执行确实更有利吗？</p>
<p>3、为某些组件（大型）提供一个当这个大型组件需要被回收的时候用于合理处理其中的一些小组件的方法（例如上面代码中 <code>MyComponent</code> 的 <code>onDestroy</code> 方法），在这个方法中，确保正确的处理一些需要处理的对象（将某些引用置为 null、释放一些其他（CPU…）资源）。</p>
<p>好了，关于 Java 内部类的介绍就到这里了，通过这篇文章相信你对 Java 内部类已经有了一个比较深入的理解。<br>如果博客中有什么不正确的地方，还请多多指点。如果这篇文章对您有帮助，请不要吝啬您的赞，欢迎继续关注我的其他文章。</p>
<p>谢谢观看。。。</p>
<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e44c3c0e64.css" rel="stylesheet">
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/06/Java/Java_%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="prev" title="Java/Java_虚拟机">
      <i class="fa fa-chevron-left"></i> Java/Java_虚拟机
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/06/Java/Linux/" rel="next" title="Java/Linux">
      Java/Linux <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.</span> <span class="nav-text">前言#</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="DXQ"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">DXQ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DXQ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">188k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:51</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
